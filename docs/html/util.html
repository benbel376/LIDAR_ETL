<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>util API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>util</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pdal
import json
import geopandas
import pandas as pd
from shapely.geometry import Polygon, Point, mapping
import numpy as np
from pyproj import Proj, transform
import folium
import laspy as lp
import richdem as rd
import rasterio
import math
from branca.element import Figure
import urllib.request, json 
import warnings
import matplotlib.pyplot as plt
warnings.filterwarnings(&#34;ignore&#34;)

class Util:
    
    def create_meta(self, region_list, name, url, offset=0):
        &#34;&#34;&#34;creates meta data
        
        Params:
        
            region_list: csv or txt file with list of regions.
            
            name: name for the metadata to generate.
            
            url: the url to fetch the metadata from.
            
            offset: the line number in the region_list to start fetching data from.
            
        return: None.
        &#34;&#34;&#34;
        metadata = {}
        urlf = &#34;&#34;+str(url)
        counter = 0 + offset
        for i in range(len(region_list)):
            newurl = urlf+str(region_list[i+offset])+&#34;ept.json&#34;
            counter = counter+1
            try:
                with open(name, &#39;r&#39;) as openfile:
                    # Reading from json file
                    metadata = json.load(openfile)
            except:
                pass
            print((newurl), counter)
            with urllib.request.urlopen(newurl, timeout=1000000) as url:
                data = json.loads(url.read().decode())
                metadata[f&#39;{region_list[i+offset]}&#39;] = data
            with open(name, &#34;w&#34;) as outfile:
                outfile.write(json.dumps(metadata))
                
                
    # loading json file
    def read_json(self, json_path):
        &#34;&#34;&#34; 
        reads a json file and returns a pthon dictionary

        params:
        
            json_path: path to file

        return: a python dictionary
        &#34;&#34;&#34;
        try:
            with open(json_path) as js:
                json_obj = json.load(js)
            return json_obj

        except FileNotFoundError:
            print(&#39;File not found.&#39;)
    
    
    
    def compare(self, meta_loc, coor):
        &#34;&#34;&#34; 
        compares meta_loc with the polygon coordinate to determine where the polygon is found
        
        params:
        
            meta_loc: the location of the metadata
            
            coor: the polygon coordinates: it is a list of points.
            
        return: regions that hold the polygon and their boundaries.
        
        &#34;&#34;&#34;
        
        try:
            with open(meta_loc, &#39;r&#39;) as openfile:
                # Reading from json file
                metadata = json.load(openfile)
                metakeys = list(metadata.keys())
        except:
            pass
        selection_list = {}
        for i in range(len(metakeys)):
            bounds = metadata[metakeys[i]][&#39;boundsConforming&#39;]
            xMin, yMin = float(bounds[0]), float(bounds[1])
            xMax, yMax = float(bounds[3]), float(bounds[4])
            for points in coor:
                px = float(points[0])
                py = float(points[1])
                if((px &gt;= xMin) and (px &lt;= xMax)):
                    if((py &gt;= yMin) and (py &lt;= yMax)):
                        save_bounds = bounds[:]
                        save_bounds.pop(2)
                        save_bounds.pop(4)
                        selection_list[metakeys[i]] = save_bounds

        return [list(selection_list.keys()), list(selection_list.values())]




    def convert_EPSG(self, fromT, toT, lon, lat):
        &#34;&#34;&#34; 
        converts EPSG formats from one type to another
        
        params: 
        
            fromT: the initial epsg value to convert from in integer
            
            toT: the fianl epsg value to convert to in integer
            
            lon: the longitude value in old format
            
            lat: the latitude value in old format
            
        return: new longitude and latitude values in the new format
        
        &#34;&#34;&#34;
        input1 = Proj(init=f&#39;epsg:{fromT}&#39;)
        input2 = Proj(init=f&#39;epsg:{toT}&#39;) 
        x, y = transform(input1,input2, lon, lat)
        return [x, y]
        
    def loop_EPSG_converter(self, listin, fromT, toT):
        &#34;&#34;&#34; 
        Runs the convert_EPSG function for a list of points
        
        Params:
        
            listin: list of points
            
            fromT: old epsg format
            
            toT: new epsg format
            
        Return: converted list of points. 
        
        
        &#34;&#34;&#34;
        converted = []
        for item in listin:
            converted.append(self.convert_EPSG(fromT, toT, item[0], item[1]))
            
        return converted

    def generate_polygon(self, coor, epsg):
        &#34;&#34;&#34; 
        Generates a polygon based on a list of coordinates specifed
        
        Params:
        
            coor: 2D list containing points and their x, y coordinates or lat and long
            
            epsg: the format to put them in
            
        Return: a geopandas dataframe containing the polygon
        
        &#34;&#34;&#34;
        polygon_g = Polygon(coor)
        crs = {&#39;init&#39;: &#39;epsg:&#39;+str(epsg)}
        polygon = geopandas.GeoDataFrame(index=[0], crs=crs, geometry=[polygon_g])       
        
        return polygon


    def show_on_map(self, polygon, zoom):
        &#34;&#34;&#34; 
        Shows polygon on a map
        
        params: 
        
            polygon: the polygon to show on the map. a geopandas polygon
            
            zoom: zoom factor on the map (integer)
            
        Return: a figure
        
        &#34;&#34;&#34;
        
        #region selection
        poly = mapping((polygon.iloc[:,0][0]))
        tmp = poly[&#39;coordinates&#39;][0][0]
        anchor = [tmp[1], tmp[0]]
        fig = Figure(width=600, height=400)
        m = folium.Map(anchor, zoom_start=zoom, tiles=&#39;cartodbpositron&#39;)
        folium.GeoJson(polygon).add_to(m)
        folium.LatLngPopup().add_to(m)
        fig.add_child(m)
        
        return fig


    def modify_pipe_json(self, json_loc, url, path, in_epsg, out_epsg, polygon_b, bounds=None):
        &#34;&#34;&#34; 
        Updates the pipeline for pdal in json format.
        
        params: 
        
            json_loc: location of the pipleine json file
            
            url: the data url to add into the pipeline
            
            path: data path to add to url. location to save the generated data to.
            
            in_epsg: the input epsg to add to pipeline
            
            out_epsg: te output epsg to add to pipeline
            
            polygon_b: the polygon boundary coordinates in string to add to the pipeline
            
            bounds: the bounds of the data to be fetched in string of lists
            
        return: a dictionary to save 
        
        &#34;&#34;&#34;
        dicti = self.read_json(json_loc)
        if bounds is not None:
            dicti[&#39;pipeline&#39;][0][&#39;bounds&#39;] = f&#34;([{bounds[0]},{bounds[2]}],[{bounds[1]},{bounds[3]}])&#34;
        dicti[&#39;pipeline&#39;][0][&#39;polygon&#39;] = str(polygon_b.iloc[:,0][0])
        dicti[&#39;pipeline&#39;][0][&#39;filename&#39;] = url
        dicti[&#39;pipeline&#39;][2][&#39;in_srs&#39;] = f&#34;EPSG:{in_epsg}&#34;
        dicti[&#39;pipeline&#39;][2][&#39;out_srs&#39;] = f&#34;EPSG:{out_epsg}&#34;
        dicti[&#39;pipeline&#39;][3][&#39;filename&#39;] = f&#34;{path}&#34;
        
        return dicti</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="util.Util"><code class="flex name class">
<span>class <span class="ident">Util</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Util:
    
    def create_meta(self, region_list, name, url, offset=0):
        &#34;&#34;&#34;creates meta data
        
        Params:
        
            region_list: csv or txt file with list of regions.
            
            name: name for the metadata to generate.
            
            url: the url to fetch the metadata from.
            
            offset: the line number in the region_list to start fetching data from.
            
        return: None.
        &#34;&#34;&#34;
        metadata = {}
        urlf = &#34;&#34;+str(url)
        counter = 0 + offset
        for i in range(len(region_list)):
            newurl = urlf+str(region_list[i+offset])+&#34;ept.json&#34;
            counter = counter+1
            try:
                with open(name, &#39;r&#39;) as openfile:
                    # Reading from json file
                    metadata = json.load(openfile)
            except:
                pass
            print((newurl), counter)
            with urllib.request.urlopen(newurl, timeout=1000000) as url:
                data = json.loads(url.read().decode())
                metadata[f&#39;{region_list[i+offset]}&#39;] = data
            with open(name, &#34;w&#34;) as outfile:
                outfile.write(json.dumps(metadata))
                
                
    # loading json file
    def read_json(self, json_path):
        &#34;&#34;&#34; 
        reads a json file and returns a pthon dictionary

        params:
        
            json_path: path to file

        return: a python dictionary
        &#34;&#34;&#34;
        try:
            with open(json_path) as js:
                json_obj = json.load(js)
            return json_obj

        except FileNotFoundError:
            print(&#39;File not found.&#39;)
    
    
    
    def compare(self, meta_loc, coor):
        &#34;&#34;&#34; 
        compares meta_loc with the polygon coordinate to determine where the polygon is found
        
        params:
        
            meta_loc: the location of the metadata
            
            coor: the polygon coordinates: it is a list of points.
            
        return: regions that hold the polygon and their boundaries.
        
        &#34;&#34;&#34;
        
        try:
            with open(meta_loc, &#39;r&#39;) as openfile:
                # Reading from json file
                metadata = json.load(openfile)
                metakeys = list(metadata.keys())
        except:
            pass
        selection_list = {}
        for i in range(len(metakeys)):
            bounds = metadata[metakeys[i]][&#39;boundsConforming&#39;]
            xMin, yMin = float(bounds[0]), float(bounds[1])
            xMax, yMax = float(bounds[3]), float(bounds[4])
            for points in coor:
                px = float(points[0])
                py = float(points[1])
                if((px &gt;= xMin) and (px &lt;= xMax)):
                    if((py &gt;= yMin) and (py &lt;= yMax)):
                        save_bounds = bounds[:]
                        save_bounds.pop(2)
                        save_bounds.pop(4)
                        selection_list[metakeys[i]] = save_bounds

        return [list(selection_list.keys()), list(selection_list.values())]




    def convert_EPSG(self, fromT, toT, lon, lat):
        &#34;&#34;&#34; 
        converts EPSG formats from one type to another
        
        params: 
        
            fromT: the initial epsg value to convert from in integer
            
            toT: the fianl epsg value to convert to in integer
            
            lon: the longitude value in old format
            
            lat: the latitude value in old format
            
        return: new longitude and latitude values in the new format
        
        &#34;&#34;&#34;
        input1 = Proj(init=f&#39;epsg:{fromT}&#39;)
        input2 = Proj(init=f&#39;epsg:{toT}&#39;) 
        x, y = transform(input1,input2, lon, lat)
        return [x, y]
        
    def loop_EPSG_converter(self, listin, fromT, toT):
        &#34;&#34;&#34; 
        Runs the convert_EPSG function for a list of points
        
        Params:
        
            listin: list of points
            
            fromT: old epsg format
            
            toT: new epsg format
            
        Return: converted list of points. 
        
        
        &#34;&#34;&#34;
        converted = []
        for item in listin:
            converted.append(self.convert_EPSG(fromT, toT, item[0], item[1]))
            
        return converted

    def generate_polygon(self, coor, epsg):
        &#34;&#34;&#34; 
        Generates a polygon based on a list of coordinates specifed
        
        Params:
        
            coor: 2D list containing points and their x, y coordinates or lat and long
            
            epsg: the format to put them in
            
        Return: a geopandas dataframe containing the polygon
        
        &#34;&#34;&#34;
        polygon_g = Polygon(coor)
        crs = {&#39;init&#39;: &#39;epsg:&#39;+str(epsg)}
        polygon = geopandas.GeoDataFrame(index=[0], crs=crs, geometry=[polygon_g])       
        
        return polygon


    def show_on_map(self, polygon, zoom):
        &#34;&#34;&#34; 
        Shows polygon on a map
        
        params: 
        
            polygon: the polygon to show on the map. a geopandas polygon
            
            zoom: zoom factor on the map (integer)
            
        Return: a figure
        
        &#34;&#34;&#34;
        
        #region selection
        poly = mapping((polygon.iloc[:,0][0]))
        tmp = poly[&#39;coordinates&#39;][0][0]
        anchor = [tmp[1], tmp[0]]
        fig = Figure(width=600, height=400)
        m = folium.Map(anchor, zoom_start=zoom, tiles=&#39;cartodbpositron&#39;)
        folium.GeoJson(polygon).add_to(m)
        folium.LatLngPopup().add_to(m)
        fig.add_child(m)
        
        return fig


    def modify_pipe_json(self, json_loc, url, path, in_epsg, out_epsg, polygon_b, bounds=None):
        &#34;&#34;&#34; 
        Updates the pipeline for pdal in json format.
        
        params: 
        
            json_loc: location of the pipleine json file
            
            url: the data url to add into the pipeline
            
            path: data path to add to url. location to save the generated data to.
            
            in_epsg: the input epsg to add to pipeline
            
            out_epsg: te output epsg to add to pipeline
            
            polygon_b: the polygon boundary coordinates in string to add to the pipeline
            
            bounds: the bounds of the data to be fetched in string of lists
            
        return: a dictionary to save 
        
        &#34;&#34;&#34;
        dicti = self.read_json(json_loc)
        if bounds is not None:
            dicti[&#39;pipeline&#39;][0][&#39;bounds&#39;] = f&#34;([{bounds[0]},{bounds[2]}],[{bounds[1]},{bounds[3]}])&#34;
        dicti[&#39;pipeline&#39;][0][&#39;polygon&#39;] = str(polygon_b.iloc[:,0][0])
        dicti[&#39;pipeline&#39;][0][&#39;filename&#39;] = url
        dicti[&#39;pipeline&#39;][2][&#39;in_srs&#39;] = f&#34;EPSG:{in_epsg}&#34;
        dicti[&#39;pipeline&#39;][2][&#39;out_srs&#39;] = f&#34;EPSG:{out_epsg}&#34;
        dicti[&#39;pipeline&#39;][3][&#39;filename&#39;] = f&#34;{path}&#34;
        
        return dicti</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="util.Util.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, meta_loc, coor)</span>
</code></dt>
<dd>
<div class="desc"><p>compares meta_loc with the polygon coordinate to determine where the polygon is found</p>
<p>params:</p>
<pre><code>meta_loc: the location of the metadata

coor: the polygon coordinates: it is a list of points.
</code></pre>
<p>return: regions that hold the polygon and their boundaries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare(self, meta_loc, coor):
    &#34;&#34;&#34; 
    compares meta_loc with the polygon coordinate to determine where the polygon is found
    
    params:
    
        meta_loc: the location of the metadata
        
        coor: the polygon coordinates: it is a list of points.
        
    return: regions that hold the polygon and their boundaries.
    
    &#34;&#34;&#34;
    
    try:
        with open(meta_loc, &#39;r&#39;) as openfile:
            # Reading from json file
            metadata = json.load(openfile)
            metakeys = list(metadata.keys())
    except:
        pass
    selection_list = {}
    for i in range(len(metakeys)):
        bounds = metadata[metakeys[i]][&#39;boundsConforming&#39;]
        xMin, yMin = float(bounds[0]), float(bounds[1])
        xMax, yMax = float(bounds[3]), float(bounds[4])
        for points in coor:
            px = float(points[0])
            py = float(points[1])
            if((px &gt;= xMin) and (px &lt;= xMax)):
                if((py &gt;= yMin) and (py &lt;= yMax)):
                    save_bounds = bounds[:]
                    save_bounds.pop(2)
                    save_bounds.pop(4)
                    selection_list[metakeys[i]] = save_bounds

    return [list(selection_list.keys()), list(selection_list.values())]</code></pre>
</details>
</dd>
<dt id="util.Util.convert_EPSG"><code class="name flex">
<span>def <span class="ident">convert_EPSG</span></span>(<span>self, fromT, toT, lon, lat)</span>
</code></dt>
<dd>
<div class="desc"><p>converts EPSG formats from one type to another</p>
<p>params: </p>
<pre><code>fromT: the initial epsg value to convert from in integer

toT: the fianl epsg value to convert to in integer

lon: the longitude value in old format

lat: the latitude value in old format
</code></pre>
<p>return: new longitude and latitude values in the new format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_EPSG(self, fromT, toT, lon, lat):
    &#34;&#34;&#34; 
    converts EPSG formats from one type to another
    
    params: 
    
        fromT: the initial epsg value to convert from in integer
        
        toT: the fianl epsg value to convert to in integer
        
        lon: the longitude value in old format
        
        lat: the latitude value in old format
        
    return: new longitude and latitude values in the new format
    
    &#34;&#34;&#34;
    input1 = Proj(init=f&#39;epsg:{fromT}&#39;)
    input2 = Proj(init=f&#39;epsg:{toT}&#39;) 
    x, y = transform(input1,input2, lon, lat)
    return [x, y]</code></pre>
</details>
</dd>
<dt id="util.Util.create_meta"><code class="name flex">
<span>def <span class="ident">create_meta</span></span>(<span>self, region_list, name, url, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>creates meta data</p>
<h2 id="params">Params</h2>
<p>region_list: csv or txt file with list of regions.</p>
<p>name: name for the metadata to generate.</p>
<p>url: the url to fetch the metadata from.</p>
<p>offset: the line number in the region_list to start fetching data from.</p>
<p>return: None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_meta(self, region_list, name, url, offset=0):
    &#34;&#34;&#34;creates meta data
    
    Params:
    
        region_list: csv or txt file with list of regions.
        
        name: name for the metadata to generate.
        
        url: the url to fetch the metadata from.
        
        offset: the line number in the region_list to start fetching data from.
        
    return: None.
    &#34;&#34;&#34;
    metadata = {}
    urlf = &#34;&#34;+str(url)
    counter = 0 + offset
    for i in range(len(region_list)):
        newurl = urlf+str(region_list[i+offset])+&#34;ept.json&#34;
        counter = counter+1
        try:
            with open(name, &#39;r&#39;) as openfile:
                # Reading from json file
                metadata = json.load(openfile)
        except:
            pass
        print((newurl), counter)
        with urllib.request.urlopen(newurl, timeout=1000000) as url:
            data = json.loads(url.read().decode())
            metadata[f&#39;{region_list[i+offset]}&#39;] = data
        with open(name, &#34;w&#34;) as outfile:
            outfile.write(json.dumps(metadata))</code></pre>
</details>
</dd>
<dt id="util.Util.generate_polygon"><code class="name flex">
<span>def <span class="ident">generate_polygon</span></span>(<span>self, coor, epsg)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a polygon based on a list of coordinates specifed</p>
<h2 id="params">Params</h2>
<p>coor: 2D list containing points and their x, y coordinates or lat and long</p>
<p>epsg: the format to put them in</p>
<p>Return: a geopandas dataframe containing the polygon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_polygon(self, coor, epsg):
    &#34;&#34;&#34; 
    Generates a polygon based on a list of coordinates specifed
    
    Params:
    
        coor: 2D list containing points and their x, y coordinates or lat and long
        
        epsg: the format to put them in
        
    Return: a geopandas dataframe containing the polygon
    
    &#34;&#34;&#34;
    polygon_g = Polygon(coor)
    crs = {&#39;init&#39;: &#39;epsg:&#39;+str(epsg)}
    polygon = geopandas.GeoDataFrame(index=[0], crs=crs, geometry=[polygon_g])       
    
    return polygon</code></pre>
</details>
</dd>
<dt id="util.Util.loop_EPSG_converter"><code class="name flex">
<span>def <span class="ident">loop_EPSG_converter</span></span>(<span>self, listin, fromT, toT)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the convert_EPSG function for a list of points</p>
<h2 id="params">Params</h2>
<p>listin: list of points</p>
<p>fromT: old epsg format</p>
<p>toT: new epsg format</p>
<p>Return: converted list of points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop_EPSG_converter(self, listin, fromT, toT):
    &#34;&#34;&#34; 
    Runs the convert_EPSG function for a list of points
    
    Params:
    
        listin: list of points
        
        fromT: old epsg format
        
        toT: new epsg format
        
    Return: converted list of points. 
    
    
    &#34;&#34;&#34;
    converted = []
    for item in listin:
        converted.append(self.convert_EPSG(fromT, toT, item[0], item[1]))
        
    return converted</code></pre>
</details>
</dd>
<dt id="util.Util.modify_pipe_json"><code class="name flex">
<span>def <span class="ident">modify_pipe_json</span></span>(<span>self, json_loc, url, path, in_epsg, out_epsg, polygon_b, bounds=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the pipeline for pdal in json format.</p>
<p>params: </p>
<pre><code>json_loc: location of the pipleine json file

url: the data url to add into the pipeline

path: data path to add to url. location to save the generated data to.

in_epsg: the input epsg to add to pipeline

out_epsg: te output epsg to add to pipeline

polygon_b: the polygon boundary coordinates in string to add to the pipeline

bounds: the bounds of the data to be fetched in string of lists
</code></pre>
<p>return: a dictionary to save</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modify_pipe_json(self, json_loc, url, path, in_epsg, out_epsg, polygon_b, bounds=None):
    &#34;&#34;&#34; 
    Updates the pipeline for pdal in json format.
    
    params: 
    
        json_loc: location of the pipleine json file
        
        url: the data url to add into the pipeline
        
        path: data path to add to url. location to save the generated data to.
        
        in_epsg: the input epsg to add to pipeline
        
        out_epsg: te output epsg to add to pipeline
        
        polygon_b: the polygon boundary coordinates in string to add to the pipeline
        
        bounds: the bounds of the data to be fetched in string of lists
        
    return: a dictionary to save 
    
    &#34;&#34;&#34;
    dicti = self.read_json(json_loc)
    if bounds is not None:
        dicti[&#39;pipeline&#39;][0][&#39;bounds&#39;] = f&#34;([{bounds[0]},{bounds[2]}],[{bounds[1]},{bounds[3]}])&#34;
    dicti[&#39;pipeline&#39;][0][&#39;polygon&#39;] = str(polygon_b.iloc[:,0][0])
    dicti[&#39;pipeline&#39;][0][&#39;filename&#39;] = url
    dicti[&#39;pipeline&#39;][2][&#39;in_srs&#39;] = f&#34;EPSG:{in_epsg}&#34;
    dicti[&#39;pipeline&#39;][2][&#39;out_srs&#39;] = f&#34;EPSG:{out_epsg}&#34;
    dicti[&#39;pipeline&#39;][3][&#39;filename&#39;] = f&#34;{path}&#34;
    
    return dicti</code></pre>
</details>
</dd>
<dt id="util.Util.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json_path)</span>
</code></dt>
<dd>
<div class="desc"><p>reads a json file and returns a pthon dictionary</p>
<p>params:</p>
<pre><code>json_path: path to file
</code></pre>
<p>return: a python dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json_path):
    &#34;&#34;&#34; 
    reads a json file and returns a pthon dictionary

    params:
    
        json_path: path to file

    return: a python dictionary
    &#34;&#34;&#34;
    try:
        with open(json_path) as js:
            json_obj = json.load(js)
        return json_obj

    except FileNotFoundError:
        print(&#39;File not found.&#39;)</code></pre>
</details>
</dd>
<dt id="util.Util.show_on_map"><code class="name flex">
<span>def <span class="ident">show_on_map</span></span>(<span>self, polygon, zoom)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows polygon on a map</p>
<p>params: </p>
<pre><code>polygon: the polygon to show on the map. a geopandas polygon

zoom: zoom factor on the map (integer)
</code></pre>
<p>Return: a figure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_on_map(self, polygon, zoom):
    &#34;&#34;&#34; 
    Shows polygon on a map
    
    params: 
    
        polygon: the polygon to show on the map. a geopandas polygon
        
        zoom: zoom factor on the map (integer)
        
    Return: a figure
    
    &#34;&#34;&#34;
    
    #region selection
    poly = mapping((polygon.iloc[:,0][0]))
    tmp = poly[&#39;coordinates&#39;][0][0]
    anchor = [tmp[1], tmp[0]]
    fig = Figure(width=600, height=400)
    m = folium.Map(anchor, zoom_start=zoom, tiles=&#39;cartodbpositron&#39;)
    folium.GeoJson(polygon).add_to(m)
    folium.LatLngPopup().add_to(m)
    fig.add_child(m)
    
    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="util.Util" href="#util.Util">Util</a></code></h4>
<ul class="two-column">
<li><code><a title="util.Util.compare" href="#util.Util.compare">compare</a></code></li>
<li><code><a title="util.Util.convert_EPSG" href="#util.Util.convert_EPSG">convert_EPSG</a></code></li>
<li><code><a title="util.Util.create_meta" href="#util.Util.create_meta">create_meta</a></code></li>
<li><code><a title="util.Util.generate_polygon" href="#util.Util.generate_polygon">generate_polygon</a></code></li>
<li><code><a title="util.Util.loop_EPSG_converter" href="#util.Util.loop_EPSG_converter">loop_EPSG_converter</a></code></li>
<li><code><a title="util.Util.modify_pipe_json" href="#util.Util.modify_pipe_json">modify_pipe_json</a></code></li>
<li><code><a title="util.Util.read_json" href="#util.Util.read_json">read_json</a></code></li>
<li><code><a title="util.Util.show_on_map" href="#util.Util.show_on_map">show_on_map</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>